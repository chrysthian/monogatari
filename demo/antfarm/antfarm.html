<!DOCTYPE html>
<html>
    <head>
        <title>Ant farm</title>
        <style type="text/css">
        body {
          margin: 0;
          padding: 0;
          overflow: hidden;
        }
        </style>
        <script type="text/javascript" src="../../lib/Require.js"></script>
        <script>

        require.config( {
          baseUrl : '../../src',
          paths: {
              lib: '../lib',
              demo: '../demo/antfarm/scripts'
          }
        } );

        require( [ 'Monogatari', 'demo/Graph', 'demo/AStar', 'demo/Tilemap' ], function( m, _Graph,  _AStar, _Tilemap ) {

                    var maze = [ [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                                 [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0],
                                 [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0],
                                 [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0],
                                 [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                                 [1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                                 [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1],
                                 [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
                                 [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
                                 [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
                                 [1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                                 [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
                                 [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1],
                                 [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
                                 [1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
                                 [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1],
                                 [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
                                 [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0]];


                    var graph = new _Graph( maze );
                    /*
                    var start = graph.grid[ 9 ][ 11 ];
                    var end = graph.grid[ 10 ][ 6 ];
                    var path = _AStar.search( graph, start, end );
                    console.log( path );
                    printAStar( maze, path );

                    start = graph.grid[ 9 ][ 0 ];
                    end = graph.grid[ 0 ][ 9 ];
                    path = _AStar.search( graph, start, end );
                    console.log( path );
                    printAStar( maze, path );

                    start = graph.grid[ 19 ][ 0 ];
                    end = graph.grid[ 0 ][ 19 ];
                    path = _AStar.search( graph, start, end );
                    console.log( path );
                    printAStar( maze, path );
                    */

                    function printAStar( maze, path ) {
                      var line = "";

                      for ( var i = 0; i < maze.length; i++ ) {
                        for ( var j = 0; j < maze[ i ].length; j++ ) {
                          line += ( findNode( path, i, j ) ) ? " * " : ( maze[ i ][ j ] === 0 ) ? " | " : " . ";
                        }
                        console.log( line );
                        line = "";
                      }
                    };

                    function findNode( path, x, y ) {
                      var node;

                      for ( var i = 0; i < path.length; i++ ) {
                        if ( path[ i ].x === x && path[ i ].y === y )
                          return true;
                      }

                      return false;
                    }

                    m.init( "#98FB98", 1216, 896 );
                    var r = new m.Random();

                    var tilemap = new m.GameObject( 'tilemap' );
                    tilemap.position.set( m.sceneManager.canvasWidth / 2, m.sceneManager.canvasHeight / 2, 0 );
                    var tileset = new _Tilemap( maze, 'assets/sprites/tileset.png', 2, 1 );
                    tilemap.addComponent( tileset );
                    m.world.children.push( tilemap );

                    // ant nest
                    var nest = new m.GameObject( 'nest' );
                    nest.position.set( 592, 432, 0 );

                    var sprite = new m.Sprite( 'assets/sprites/nest.png', 32, 32 );
                    nest.addComponent( sprite );

                    m.sceneManager.attachToScene( nest );
                    m.world.children.push( nest );

                    var NUM_ANTS = 40;

                    var ants = new m.Map();
                    var antIt = ants.iterator();

                    function bufferAnts() {
                      var ant = null;

                      for ( var i = 0; i < NUM_ANTS; i++ ) {
                        var sprite = new m.Sprite( 'assets/sprites/ant.png', 16, 16 );
                        ant = new m.GameObject( 'ant_' + i );

                        ant.position.set( -2000, 3000, 1 );

                        ant.isActive = false;
                        ant.isVisible = false;
                        ant.target = m.mouse.position;
                        ant.withFood = false;

                        ant.addComponent( sprite );

                        ant.update = function() {
                          if ( this.isActive ) {
                            var speed = 150 / m.timer.fps;

                            this.position.x += this.rotation.x * speed;
                            this.position.y += this.rotation.y * speed;
                          }
                        }

                        ant.reset = function() {
                          this.isActive = false;
                          this.isVisible = false;
                          this.position.set( -2000, 3000, 1 );
                          this.withFood = false;
                        }

                        m.sceneManager.attachToScene( ant );
                        m.world.children.push( ant );
                        ants.put( ant.id, ant );
                      }
                    }
                    bufferAnts();

                    var MAX_FOOD = 7;

                    var food = new m.Map();
                    var foodIt = food.iterator();

                    function bufferFood() {
                      var candy = null;

                      for ( var i = 0; i < MAX_FOOD; i++ ) {
                        var sprite = new m.Sprite( 'assets/sprites/food.png', 16, 16 );
                        candy = new m.GameObject( 'food_' + i );

                        candy.position.set( -2000, 2000, 0 );

                        candy.isActive = false;
                        candy.isVisible = false;

                        candy.addComponent( sprite );

                        m.sceneManager.attachToScene( candy );
                        m.world.children.push( candy );
                        food.put( candy.id, candy );
                      }
                    }
                    bufferFood();

                    var TIME_BETWEEN_FOOD = 500;
                    lastFoodPlaced = m.timer.time;
                    function spawnFood() {
                      var obj;

                      if ( ( m.timer.time - lastFoodPlaced ) > TIME_BETWEEN_FOOD ) {

                        foodIt.first();

                        while ( foodIt.hasNext() ) {
                          obj = foodIt.next();

                          if ( obj && !obj.isActive && !obj.isVisible ) {
                            obj.isActive = true;
                            obj.isVisible = true;

                            obj.position.set( placer.position.x, placer.position.y, 0 );

                            var start = graph.grid[ tileset.getTileYFromPosition( nest.position.y + 16 ) ][ tileset
                                .getTileXFromPosition( nest.position.x + 16 ) ];
                            var end = graph.grid[ tileset.getTileYFromPosition( placer.position.y ) ][ tileset
                                .getTileXFromPosition( placer.position.x ) ];
                            var path = _AStar.search( graph, start, end );
                            console.log( path );
                            printAStar( maze, path );

                            lastFoodPlaced = m.timer.time;

                            return;
                          }
                        }

                      }
                    }

                    var timeBetweenAntSpawn = 250;
                    var lastSpawn = m.timer.time;
                    function spawnAnts() {
                      var food, ant, targets = [];

                      if ( ( m.timer.time - lastSpawn ) > timeBetweenAntSpawn ) {
                        foodIt.first();
                        while ( foodIt.hasNext() ) {
                          food = foodIt.next();
                          if ( food && food.isActive && food.isVisible ) {
                            targets.push( food.position );
                          }
                        }

                        if ( targets.length > 0 ) {
                          antIt.first();
                          while ( antIt.hasNext() ) {
                            ant = antIt.next();

                            if ( ant && !ant.isActive && !ant.isVisible ) {
                              ant.isActive = true;
                              ant.isVisible = true;

                              ant.position.set( nest.position.x, nest.position.y, 0 );

                              ant.target = targets[ r.integer( {
                                min : 0,
                                max : targets.length - 1
                              } ) ];
                              ant.lookAt( ant.target );

                              timeBetweenAntSpawn = ( targets.length > 0 ) ? r.integer( {
                                min : 300,
                                max : 500
                              } ) - targets.length * 20 : 250;
                              lastSpawn = m.timer.time;

                              return;
                            }
                          }
                        }
                      }
                    }

                    function collision( positionA, radiusA, positionB, radiusB ) {
                      var dist = positionA.distanceTo( positionB );
                      var radius = radiusA + radiusB;
                      return ( dist < radius ) ? true : false;
                    }

                    function checkCollisions() {
                      // verifica colisão de ants com food
                      var a = null;
                      var f = null;

                      antIt.first();
                      while ( antIt.hasNext() ) {
                        a = antIt.next();
                        if ( a && a.isActive && a.isVisible ) {
                          foodIt.first();
                          while ( foodIt.hasNext() ) {
                            f = foodIt.next();
                            if ( collision( a.position, 16, f.position, 16 ) ) {
                              a.withFood = true;
                              a.target = nest.position;
                              a.lookAt( a.target );
                            }
                          }
                        }
                      }

                      antIt.first();
                      while ( antIt.hasNext() ) {
                        a = antIt.next();

                        if ( a && a.isActive && a.isVisible && collision( a.position, 16, nest.position, 16 ) && a.withFood ) {
                          a.reset();
                        }
                      }
                    }

                    var placer = new m.GameObject( 'placer' );
                    var geom = new m.BaseThree();
                    geom.geometry = new THREE.PlaneGeometry( 32, 32, 1, 1 );
                    geom.material = new THREE.MeshBasicMaterial( {
                      side : THREE.BackSide,
                      color : 0x0055FF,
                      transparent : true,
                      opacity : 0.3
                    } );
                    geom.mesh = new THREE.Mesh( geom.geometry, geom.material );
                    placer.addComponent( geom );

                    placer.update = function() {
                      this.position.x = m.math.nearestMultiple( m.mouse.position.x, 32 );
                      this.position.y = m.math.nearestMultiple( m.mouse.position.y, 32 );
                      this.position.z = 1;
                    }

                    m.sceneManager.attachToScene( placer );
                    m.world.children.push( placer );

                    var parsed = false;
                    function checkTileSet() {
                      if ( tileset.spritesheet.image && !parsed ) {
                        tileset.parse();
                        tileset.renderIntoBuffer();
                        m.sceneManager.attachToScene( tilemap );
                        parsed = true;

                      }
                    }

                    m.world.update = function() {
                      if ( m.mouse.isDown( m.mouse.LMB ) ) {
                        spawnFood();
                      }
                      checkTileSet();
                      spawnAnts();
                      checkCollisions();
                    }

                    m.run();
                  } );
</script>
</head>
</html>